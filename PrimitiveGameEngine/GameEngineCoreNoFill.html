<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
	<Title>"Modularizing WebGL"</TITLE>
		
		<!-- 
		GLSL is the language used for shaders (GL Shader Language)
		
		Attribute - you specify how to pull the data out of the buffers you supply.
		Buffers - Data loaded onto the GPU (Normally vertex information)
		
		Uniforms - global variables (in GLSL) that you set before you run the shader program
		
		Textures - Textures are arrays of data you can randomly acces in your shader program.  
		
		Varying - are way for a vertex shader to pass data to the fragmentShader.
		-->
		<script id="2dVertexShader" type="notjs">
		attribute vec4 a_position;	
		//We now want to read in Colors
		attribute vec3 vert_color;
		//However, we want to send the color to
		//The fragment Shader
		varying vec3 fragColor;
		void main()
		{
			fragColor = vert_color;
			gl_Position=a_position;
		}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
		//Fragment shaders do not have precision so we have to set it.
		precision mediump float;
		varying vec3 fragColor;
		void main()
		{
			//gl_FragColor = vec4(0,0,1,1); //Between 0 and 1.
			gl_FragColor = vec4(fragColor,1);
		}
		</script>
		<script src="webgl_interface.js"></script>
		<script src="BasicGameObject.js"></script>

		<script>
		class main
		{	
			constructor()
			{
				this.Visual = []
				this.Solid = []
				this.Trigger = []
				this.objectCounter = 0
				this.keys = []
				this.myWEBGL = new WebGL_Interface();
				this.program = this.myWEBGL.program;
				//this.myTriangle = [];
			}
			
			UpdateAll()
			{
				for(var i in this.Visual){
					this.Visuial[i].Update();
				}
				for(var i in this.Solid){
					this.Solid[i].Update();
				}
				for(var i in this.Trigger){
					this.Trigger[i].Update();
				}
			
			}
			RenderAll()
			{
				for(var i in this.Visual){
					this.Visuial[i].Render(this.program);
				}
				for(var i in this.Solid){
					this.Solid[i].Render(this.program);
				}
				for(var i in this.Trigger){
					this.Trigger[i].Render(this.program);
				}
			
			}
			CheckCollision(loc1,rad1,loc2, rad2)
			{
				//we will code this in ourself 

				//return true if colide false if not

				//look over slides for formulas

			}

			
			CreateObject(type, prefab, loc, rot)
			{
				//type 0 = visual
				//type 1 = solid
				//type 3 = trigger

				var temp = new prefab;
				var id = "ID" + this.objectCounter;
				this.objectCounter++
				temp.id = id;
				temp.prefab = prefab;

				//deep copy
				for(let i = 0; i <3; i++){
					temp.loc[i] = loc[i];
					temp.rot[i] = rot[i];
				}

				switch(type)
				{
					case 0:
						this.Visual[id] = temp;
					break;
					case 1:
						this.Solid[id] = temp;
					break;
					case 2:
						this.Trigger[id] = temp;
					break;
					default:
					break;

				}
				return temp;

			}
			DestroyObject(id)
			{
				if(id in this.Visual){
					delete this.Visual[id];
				}
				if(id in this.Solid){
					delete this.Solid[id];
				}
				if(id in this.Trigger){
					delete this.Trigger[id];
				}
			}
			
			CheckKey(k)
			{
				//check if key code is not in dictionary 
				if(k in this.Keys){
					return this.Key[k]
				}
				return false
			}


			KeyDown(event)
			{
				this.Keys[String.fromCharCode(event.keyCode)] = true;
				//store current status of all keys in a dictionary
				//this console log should be this
				console.log(String.fromCharCode(event.keyCode) + " should be true - " + this.keys[String.fromCharCode])

				//console.log("The number of the key pressed:  "+event.keyCode+",the string of the event code: "+String.fromCharCode(event.keyCode));                   
			}

			KeyUp(event){

				this.Keys[String.fromCharCode(event.keyCode)] = false;
				console.log(String.fromCharCode(event.keyCode) + " should be false - " + this.keys[String.fromCharCode])
			}
			
			MouseClick(event)
			{
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				console.log(realX+","+realY);
				var x = -1 + 2*realX/myCanvas.width;
				var y = -1 + 2*(myCanvas.height - realY)/myCanvas.height;
				console.log("The click occurred on "+x+","+y);
			}

			
			//Static call backs go down here
			//   |
			//  \ /
			//   v
			static keyD(event)
			{
				m.KeyDown(event);
			}
			

			static mouseH(event)
			{
				m.MouseClick(event);
			}
			
			static MainLoop()
			{
				m.UpdateAll();
				m.RenderAll();
				requestAnimationFrame(main.MainLoop);
			}

		}
		
		
		</script>
		
		

	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width="640" height="400" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		<button id="myB">Clear Canvas</button>
		
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			var m = new main();
			window.onkeydown = main.keyD;
			canvas.addEventListener("click",main.mouseH);
			
			requestAnimationFrame(main.MainLoop);	
			
		</SCRIPT>
		
		<FOOTER>
		
		</FOOTER>

		
	</BODY>
	
</HTML>
		
		