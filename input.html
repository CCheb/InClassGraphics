<!DOCTYPE HTML>
<HTML lang="en">
	<Head>
	<Title>"Modularizing WebGL"</TITLE>
		
		<!-- 
		GLSL is the language used for shaders (GL Shader Language)
		
		Attribute - you specify how to pull the data out of the buffers you supply.
		Buffers - Data loaded onto the GPU (Normally vertex information)
		
		Uniforms - global variables (in GLSL) that you set before you run the shader program
		
		Textures - Textures are arrays of data you can randomly acces in your shader program.  
		
		Varying - are way for a vertex shader to pass data to the fragmentShader.
		-->
		<script id="2dVertexShader" type="notjs">
		attribute vec4 a_position;	
		//We now want to read in Colors
		attribute vec3 vert_color;
		//However, we want to send the color to
		//The fragment Shader
		varying vec3 fragColor;
		void main()
		{
			fragColor = vert_color;
			gl_Position=a_position;
		}		
		</SCRIPT>
		<script id="2dFragmentShader" type="notjs">
		//Fragment shaders do not have precision so we have to set it.
		precision mediump float;
		varying vec3 fragColor;
		void main()
		{
			//gl_FragColor = vec4(0,0,1,1); //Between 0 and 1.
			gl_FragColor = vec4(fragColor,1);
		}
		</script>
		
		<script>
			// Add something here to connect everything together
			class WebGL_Interface
			{
				constructor()
				{
					// We set out canvas size earlier, now its time to set our gl viewport
					// aka our clip space (-1 to 1) inside our canvas
					//setup viewport, we want to draw on the same size as the canvas
					gl.viewport(0,0, gl.canvas.width, gl.canvas.height);
					//set clear colors this sets our background
					gl.clearColor(1,1,1,1); //can change to black to make a spooky game
					gl.clear(gl.COLOR_BUFFER_BIT);
					//values are between 0 and 1 for black and white


					// We first make sure to grab a reference to the shader source code
					var vertexShaderSource = document.getElementById("2dVertexShader").text;
					var fragmentShaderSource = document.getElementById("2dFragmentShader").text;

					// this.webGL. Deleted
					// grabbing our compiled shaders through the createShader function
					var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
					var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);
					
					//link to program //this.program needs to be a class variable for access
					// The program takes both compiled shaders and links them together into a 
					// 'program' It is possible to have more than one program in a webgl application
					// each having their own vertex and fragment shaders
					this.program = this.createProgram(vertexShader, fragmentShader);

					//what program to use
					// Anything before the useProgram function is considered to be initiallization
					// code. Most of webgl is setting up shop/state. There is little code when it comes to
					// rendering 
					gl.useProgram(this.program);
			
				}
				createShader(type,source)
				{
					// type = shader variable (e.g. vertexShader or fragmentShader)
					// source = text/source code (e.g. vertexShaderSource)
					var shader = gl.createShader(type);
					gl.shaderSource(shader,source);

					// After linking our shader and source together, we can then compile them
					// Similar process to the C/C++ compile process
					gl.compileShader(shader);
					// Always make sure to do some error checking since webgl doesnt like
					// to talk about them automatically :)
					var success = gl.getShaderParameter(shader,gl.COMPILE_STATUS);
					if(success){
						// If everything goes well, return the compiled shader so that it can be
						// linked later
						return shader;
					}
					//else if didnt work
					console.error(gl.getShaderInfoLog(shader));
					gl.deleteShader(shader);
				}
			
				createProgram(vs,fs)
				{
					// vs = vertex shader; fs = fragment shader
					// create the program variable
					var program = gl.createProgram();
					// attaching both shaders to the program and linking them together 
					gl.attachShader(program, vs);
					gl.attachShader(program, fs);
					gl.linkProgram(program);
					// Always make sure to do some error checking 
					var success = gl.getProgramParameter(program,gl.LINK_STATUS);
					if(success){
						// if everything goes then return the complete program
						return program;
					}
					console.error(gl.getProgramInfoLog(program));
					gl.deleteProgram(program);
				}
			}


		</script>


		<!--<script src="webgl_interface.js"></script>-->
		<!--<script src="Triangle1.js"></script>-->
		<script>
		class main
		{	
			constructor()
			{
			this.x = 10;
			this.myWEBGL = new WebGL_Interface();
			this.myTriangle = [];
			}
			
			keyDown(event)
			{
				console.log("The number of the key pressed:  "+event.keyCode+
				",the string of the event code: "+String.fromCharCode(event.keyCode));                   
			}
			
			slideHandle(handle)
			{
			console.log("The slide has been changed to "+ handle.value);
			console.log("X = "+this.x);
			}
	
			canvasHandle(event)
			{
				var rect = canvas.getBoundingClientRect();
				var realX = event.clientX - rect.left;
				var realY = event.clientY - rect.top;
				console.log(realX+","+realY);
				var x = -1 + 2*event.clientX/myCanvas.width;
				var y = -1 + 2*(myCanvas.height - event.clientY)/myCanvas.height;
				console.log("The click occurred on "+x+","+y);
			}
		
			menuHandle(menu)
			{
				console.log("The menu option is "+ menu.selectedIndex);
				console.log("the menu value is "+menu.value);
			}
			
			buttonHandle()
			{
				console.log("You clicked the button");
			}	
			
			static keyD(event)
			{
				m.keyDown(event);
			}
			
			static slideH()
			{
				m.slideHandle(this);
			}
			
			static mouseH(event)
			{
				m.canvasHandle(event);
			}
			static menuH()
			{
				m.menuHandle(this);
			}
			
			static buttonH()
			{
				m.buttonHandle();
			}
		}
		
		
		</script>
		
		

	</Head>
	<BODY style="padding: 15px;">
		<HEADER>
		
		</HEADER>
		
		<CANVAS id="myCanvas" width="640" height="400" style = "border: 1px solid #000;">
			Your browser does not support canvas.
		</CANVAS>
		
		<button id="myB">Clear Canvas</button>
		
		
		<select id="mySel" size = "3">
			<option value="Circle">Circle</option>
			<option value="Square">Square</option>
			<option value="Triangle">Triangle</option>
		</select>
		
		<input id="slide" type="range" min="0" max="100" step="10" value="50"/>

		
		<FOOTER>
		
		</FOOTER>
		<SCRIPT>
			var canvas = document.getElementById("myCanvas");
			var gl = canvas.getContext("webgl");
			
			var m = new main();
			
			window.onkeydown = main.keyD;
			var slide = document.getElementById("slide");
			slide.onchange = main.slideH;
			canvas.addEventListener("click",main.mouseH);
			var mySel = document.getElementById("mySel");
			mySel.addEventListener("click", main.menuH);
			var myB = document.getElementById("myB");
			myB.addEventListener("click",main.buttonH);

			
		</SCRIPT>
		
	</BODY>
	
</HTML>
		
		